/*
 * Copyright (c) 2016, Freescale Semiconductor, Inc.
 * Copyright 2016-2017 NXP
 * All rights reserved.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

#include "fsl_debug_console.h"
#include "fsl_xrdc.h"
#include "board.h"
#include "app.h"
#include "rdmgr.h"

/*******************************************************************************
 * Definitions
 ******************************************************************************/

/*******************************************************************************
 * Variables
 ******************************************************************************/
//! @brief config block array
extern const config_block_t configBlock;

/*******************************************************************************
 * Prototypes
 ******************************************************************************/

/*******************************************************************************
 * Code
 ******************************************************************************/
void HardFault_Handler(void)
{
    PRINTF("Hard Fault\n");
    xrdc_error_t error;
    while (kStatus_Success == XRDC_GetAndClearFirstDomainError(XRDC, &error))
    {
        if (error.controller == kXRDC_MemController1)
        {
            PRINTF("  Violent access at address: 0x%x\n", error.address);

            xrdc_mem_access_config_t memConfig;
            XRDC_GetMemAccessDefaultConfig(&memConfig);
            memConfig.mem         = kXRDC_MemMrc1_1;
            memConfig.baseAddress = MEM_REG_START;
            memConfig.endAddress  = MEM_REG_END;
            /* Enable access from domain 0 (core0) */
            memConfig.policy[0] = kXRDC_AccessFlagsAlt7;
            XRDC_SetMemAccessConfig(XRDC, &memConfig);
        }

        if (error.controller == kXRDC_PeriphController0)
        {
            PRINTF("  Violent access at address: 0x%x\n", error.address);

            xrdc_periph_access_config_t periConfig;
            XRDC_GetPeriphAccessDefaultConfig(&periConfig);
            periConfig.periph = kXRDC_PeriphWdog0;
            /* Enable access from domain 0 (core0) */
            periConfig.policy[0] = kXRDC_AccessPolicyAll;
            XRDC_SetPeriphAccessConfig(XRDC, &periConfig);
        }
    }
    SDK_ISR_EXIT_BARRIER;
}

/*!
 * @brief Main function
 */
int main(void)
{
    /* Init board hardware. */
    BOARD_InitHardware();

    /* Use RDMGR to configure XRDC with config block generated by PAM tool */
    rdmgr_status_t status = kStatus_RDMGR_Success;
    status                = RDMGR_ConfigureDomainController(&configBlock);
    if (status != kStatus_RDMGR_Success)
    {
        /* Fail in XRDC configuration */
        PRINTF("XRDC configuration failed!\n");
        while (1)
            ;
    }

    PRINTF("Try write to memory at address: 0x%X\n", MEM_REG_START);
    /* Try write to memory region without access rights - should go to hard fault */
    uint32_t *addr = (uint32_t *)MEM_REG_START;
    *addr          = 0x0;

    PRINTF("Try read from WDOG0_CS register\n");
    /* Try read from WDOG0_CS register without access rights - should go to hard fault */
    (void)WDOG0->CS;

    /* Try change memory region which is locked */
    PRINTF("Try change configuration of memory region which is locked\n");

    /* Read base address of configured memory region */
    uint32_t base_address = XRDC->MRGD[0].MRGD_W[0];
    uint32_t end_address  = XRDC->MRGD[0].MRGD_W[1];

    /* Prepare new configuration of memory region */
    xrdc_mem_access_config_t memConfig;
    XRDC_GetMemAccessDefaultConfig(&memConfig);
    memConfig.mem         = kXRDC_MemMrc0_0;
    memConfig.baseAddress = base_address + MEM_REG_OFFSET;
    memConfig.endAddress  = base_address + 2 * MEM_REG_OFFSET;
    /* Enable access for both cores */
    memConfig.policy[0] = kXRDC_AccessFlagsNone;
    memConfig.policy[1] = kXRDC_AccessFlagsNone;
    XRDC_SetMemAccessConfig(XRDC, &memConfig);

    /* Read base address of configured memory region */
    uint32_t base_address2 = XRDC->MRGD[0].MRGD_W[0];
    uint32_t end_address2  = XRDC->MRGD[0].MRGD_W[1];

    /* Compare address of memory region after changes */
    if ((base_address == base_address2) && (end_address == end_address2))
    {
        /* The configuration of memory regions was not changed, because is locked */
        PRINTF("The configuration of memory region is still same\n");
    }

    while (1)
    {
    }
}
