/*
 * Copyright (c) 2016, Freescale Semiconductor, Inc.
 * Copyright 2016-2017 NXP
 * All rights reserved.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

#include "fsl_debug_console.h"
#include "fsl_xrdc.h"
#include "board.h"
#include "app.h"
#include "rdmgr.h"

/*******************************************************************************
 * Definitions
 ******************************************************************************/

typedef enum
{
    kNone,
    kSwitchToUserMode,
    kSwitchToPrivilegedMode,
    kSwitchToSecureMode,
    kSwitchToNonsecureMode,
} svc_action_t;

/*******************************************************************************
 * Prototypes
 ******************************************************************************/

/*******************************************************************************
 * Variables
 ******************************************************************************/
//! @brief config block array
extern const config_block_t configBlock;
volatile svc_action_t svc_action = kNone;

/*******************************************************************************
 * Code
 ******************************************************************************/

void HardFault_Handler(void)
{
    PRINTF("Hard Fault\n");
    PRINTF("Switch to priviledge mode\n");

/* switch to privileged mode */
#if defined(__CC_ARM) || defined(__ARMCC_VERSION)
    uint32_t r0 = 0;
#endif
    __asm("movs r0, #0x00");
    __asm("msr CONTROL, r0");
    SDK_ISR_EXIT_BARRIER;
}

void SVC_Handler(unsigned int *svc_args)
{
    xrdc_pid_config_t pidConfig;

#if defined(__CC_ARM) || defined(__ARMCC_VERSION)
    uint32_t r0 = 0;
#endif

    switch (svc_action)
    {
        case kSwitchToUserMode:
            __asm("movs r0, #0x01");
            __asm("msr CONTROL, r0");
            break;
        case kSwitchToPrivilegedMode:
            __asm("movs r0, #0x00");
            __asm("msr CONTROL, r0");
            break;
        case kSwitchToSecureMode:
            XRDC_GetPidDefaultConfig(&pidConfig);
            pidConfig.pid = 0;
            XRDC_SetPidConfig(XRDC, kXRDC_MasterCM4SystemBus, &pidConfig);
            break;
        case kSwitchToNonsecureMode:
            XRDC_GetPidDefaultConfig(&pidConfig);
            pidConfig.pid = (1 << 5);
            XRDC_SetPidConfig(XRDC, kXRDC_MasterCM4SystemBus, &pidConfig);
            break;

        case kNone:
        default:
            break;
    }
    SDK_ISR_EXIT_BARRIER;
}

void switchToUserMode()
{
    svc_action = kSwitchToUserMode;
    __asm("svc 0");
}

void switchToPrivilegedMode()
{
    svc_action = kSwitchToPrivilegedMode;
    __asm("svc 0");
}

void switchToSecureMode()
{
    svc_action = kSwitchToSecureMode;
    __asm("svc 0");
}

void switchToNonsecureMode()
{
    svc_action = kSwitchToNonsecureMode;
    __asm("svc 0");
}

/*!
 * @brief Main function
 */
int main(void)
{
    /* Init board hardware.*/
    BOARD_InitHardware();

    PRINTF("XRDC security example\n");

    /* Use RDMGR to configure XRDC with config block generated by PAM tool */
    rdmgr_status_t status;
    status = RDMGR_ConfigureDomainController(&configBlock);
    if (status != kStatus_RDMGR_Success)
    {
        /* Fail in XRDC configuration */
        PRINTF("XRDC configuration failed!\n");
        while (1)
            ;
    }

    PRINTF("Define memory region in XRDC:\n");
    PRINTF("Start address: 0x%X\n", MEM_REG_START);
    PRINTF("End address: 0x%X\n", MEM_REG_END);
    PRINTF("Access pollicy in different modes:\n");
    PRINTF("    privileged secure mode: read/write\n");
    PRINTF("    privileged nonsecure mode: read/write\n");
    PRINTF("    user secure mode: none\n");
    PRINTF("    user nonsecure mode: none\n");

    /* XRDC configuration of memory region */
    xrdc_mem_access_config_t memConfig;
    XRDC_GetMemAccessDefaultConfig(&memConfig);
    memConfig.mem         = kXRDC_MemMrc1_1;
    memConfig.baseAddress = MEM_REG_START;
    memConfig.endAddress  = MEM_REG_END;
    memConfig.policy[0]   = kXRDC_AccessFlagsAlt4;
    XRDC_SetMemAccessConfig(XRDC, &memConfig);

    PRINTF("The core is in priviledge secure mode\n");

    PRINTF("Try write to memory at address: 0x%X\n", MEM_REG_START);
    uint32_t *addr = (uint32_t *)MEM_REG_START;
    *addr          = 0x0;
    PRINTF("write OK\n");

    PRINTF("Switch the core to priviledge nonsecure mode\n");
    switchToNonsecureMode();
    PRINTF("Try write to memory at address: 0x%X\n", MEM_REG_START);
    *addr = 0x0;
    PRINTF("write OK\n");

    PRINTF("Switch the core to user secure mode\n");
    switchToSecureMode();
    switchToUserMode();

    PRINTF("Try write to memory at address: 0x%X\n", MEM_REG_START);
    *addr = 0x1;

    PRINTF("Switch the core to user nonsecure mode\n");
    switchToNonsecureMode();
    switchToUserMode();

    PRINTF("Try write to memory at address: 0x%X\n", MEM_REG_START);
    *addr = 0x0;

    while (1)
    {
    }
}
