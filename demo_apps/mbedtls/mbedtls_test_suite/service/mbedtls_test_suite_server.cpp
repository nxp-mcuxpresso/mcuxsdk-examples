/*
 * Copyright (c) 2014-2016, Freescale Semiconductor, Inc.
 * Copyright 2016 NXP
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * o Redistributions of source code must retain the above copyright notice, this list
 *   of conditions and the following disclaimer.
 *
 * o Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 *
 * o Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from this
 *   software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Generated by erpcgen 1.10.0 on Thu Oct 13 21:22:07 2022.
 *
 * AUTOGENERATED - DO NOT EDIT
 */


#include "mbedtls_test_suite_server.h"
#if ERPC_ALLOCATION_POLICY == ERPC_ALLOCATION_POLICY_DYNAMIC
#include <new>
#include "erpc_port.h"
#endif
#include "erpc_manually_constructed.hpp"

#if 11000 != ERPC_VERSION_NUMBER
#error "The generated shim code version is different to the rest of eRPC code."
#endif

using namespace erpc;
using namespace std;

#if ERPC_NESTED_CALLS_DETECTION
extern bool nestingDetection;
#endif

ERPC_MANUALLY_CONSTRUCTED_STATIC(test_suite_service, s_test_suite_service);



// Constant variable definitions
#pragma weak StringMaxSize
extern const uint8_t StringMaxSize = 11;

//! @brief Function to read struct data_t
static void read_data_t_struct(erpc::Codec * codec, data_t * data);


// Read struct data_t function implementation
static void read_data_t_struct(erpc::Codec * codec, data_t * data)
{
    if(NULL == data)
    {
        return;
    }

    uint32_t lengthTemp_0;
    codec->startReadList(&lengthTemp_0);
    data->len = lengthTemp_0;
    data->x = (int8_t *) erpc_malloc(lengthTemp_0 * sizeof(int8_t));
    if ((data->x == NULL) && (lengthTemp_0 > 0))
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    for (uint32_t listCount0 = 0U; listCount0 < lengthTemp_0; ++listCount0)
    {
        codec->read(&data->x[listCount0]);
    }
}


//! @brief Function to free space allocated inside struct data_t
static void free_data_t_struct(data_t * data);


// Free space allocated inside struct data_t function implementation
static void free_data_t_struct(data_t * data)
{
    erpc_free(data->x);
}



// Call the correct server shim based on method unique ID.
erpc_status_t test_suite_service::handleInvocation(uint32_t methodId, uint32_t sequence, Codec * codec, MessageBufferFactory *messageFactory)
{
    erpc_status_t erpcStatus;
    switch (methodId)
    {
        case ktest_suite_board_get_name_id:
        {
            erpcStatus = board_get_name_shim(codec, messageFactory, sequence);
            break;
        }

        case ktest_suite_board_aes_encrypt_ecb_id:
        {
            erpcStatus = board_aes_encrypt_ecb_shim(codec, messageFactory, sequence);
            break;
        }

        case ktest_suite_board_aes_decrypt_ecb_id:
        {
            erpcStatus = board_aes_decrypt_ecb_shim(codec, messageFactory, sequence);
            break;
        }

        case ktest_suite_board_aes_encrypt_cbc_id:
        {
            erpcStatus = board_aes_encrypt_cbc_shim(codec, messageFactory, sequence);
            break;
        }

        case ktest_suite_board_aes_decrypt_cbc_id:
        {
            erpcStatus = board_aes_decrypt_cbc_shim(codec, messageFactory, sequence);
            break;
        }

        case ktest_suite_board_aes_encrypt_cfb128_id:
        {
            erpcStatus = board_aes_encrypt_cfb128_shim(codec, messageFactory, sequence);
            break;
        }

        case ktest_suite_board_aes_decrypt_cfb128_id:
        {
            erpcStatus = board_aes_decrypt_cfb128_shim(codec, messageFactory, sequence);
            break;
        }

        case ktest_suite_board_aes_encrypt_cfb8_id:
        {
            erpcStatus = board_aes_encrypt_cfb8_shim(codec, messageFactory, sequence);
            break;
        }

        case ktest_suite_board_aes_decrypt_cfb8_id:
        {
            erpcStatus = board_aes_decrypt_cfb8_shim(codec, messageFactory, sequence);
            break;
        }

        case ktest_suite_board_mbedtls_aes_self_test_id:
        {
            erpcStatus = board_mbedtls_aes_self_test_shim(codec, messageFactory, sequence);
            break;
        }

        case ktest_suite_board_des_check_weak_id:
        {
            erpcStatus = board_des_check_weak_shim(codec, messageFactory, sequence);
            break;
        }

        case ktest_suite_board_des_encrypt_ecb_id:
        {
            erpcStatus = board_des_encrypt_ecb_shim(codec, messageFactory, sequence);
            break;
        }

        case ktest_suite_board_des_decrypt_ecb_id:
        {
            erpcStatus = board_des_decrypt_ecb_shim(codec, messageFactory, sequence);
            break;
        }

        case ktest_suite_board_des_encrypt_cbc_id:
        {
            erpcStatus = board_des_encrypt_cbc_shim(codec, messageFactory, sequence);
            break;
        }

        case ktest_suite_board_des_decrypt_cbc_id:
        {
            erpcStatus = board_des_decrypt_cbc_shim(codec, messageFactory, sequence);
            break;
        }

        case ktest_suite_board_des3_encrypt_ecb_id:
        {
            erpcStatus = board_des3_encrypt_ecb_shim(codec, messageFactory, sequence);
            break;
        }

        case ktest_suite_board_des3_decrypt_ecb_id:
        {
            erpcStatus = board_des3_decrypt_ecb_shim(codec, messageFactory, sequence);
            break;
        }

        case ktest_suite_board_des3_encrypt_cbc_id:
        {
            erpcStatus = board_des3_encrypt_cbc_shim(codec, messageFactory, sequence);
            break;
        }

        case ktest_suite_board_des3_decrypt_cbc_id:
        {
            erpcStatus = board_des3_decrypt_cbc_shim(codec, messageFactory, sequence);
            break;
        }

        case ktest_suite_board_des_key_parity_run_id:
        {
            erpcStatus = board_des_key_parity_run_shim(codec, messageFactory, sequence);
            break;
        }

        case ktest_suite_board_mbedtls_des_self_test_id:
        {
            erpcStatus = board_mbedtls_des_self_test_shim(codec, messageFactory, sequence);
            break;
        }

        case ktest_suite_board_mbedtls_sha1_id:
        {
            erpcStatus = board_mbedtls_sha1_shim(codec, messageFactory, sequence);
            break;
        }

        case ktest_suite_board_sha224_id:
        {
            erpcStatus = board_sha224_shim(codec, messageFactory, sequence);
            break;
        }

        case ktest_suite_board_mbedtls_sha256_id:
        {
            erpcStatus = board_mbedtls_sha256_shim(codec, messageFactory, sequence);
            break;
        }

        case ktest_suite_board_sha384_id:
        {
            erpcStatus = board_sha384_shim(codec, messageFactory, sequence);
            break;
        }

        case ktest_suite_board_mbedtls_sha512_id:
        {
            erpcStatus = board_mbedtls_sha512_shim(codec, messageFactory, sequence);
            break;
        }

        case ktest_suite_board_sha1_selftest_id:
        {
            erpcStatus = board_sha1_selftest_shim(codec, messageFactory, sequence);
            break;
        }

        case ktest_suite_board_sha256_selftest_id:
        {
            erpcStatus = board_sha256_selftest_shim(codec, messageFactory, sequence);
            break;
        }

        case ktest_suite_board_sha512_selftest_id:
        {
            erpcStatus = board_sha512_selftest_shim(codec, messageFactory, sequence);
            break;
        }

        default:
        {
            erpcStatus = kErpcStatus_InvalidArgument;
            break;
        }
    }

    return erpcStatus;
}

// Server shim for board_get_name of test_suite interface.
erpc_status_t test_suite_service::board_get_name_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    char * name = NULL;

    // startReadMessage() was already called before this shim was invoked.

    name = (char *) erpc_malloc((StringMaxSize + 1) * sizeof(char));
    if (name == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    else
    {
        name[StringMaxSize] = '\0';
    }

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        board_get_name(name);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, ktest_suite_service_id, ktest_suite_board_get_name_id, sequence);

        codec->writeString(strlen((const char*)name), (const char*)name);

        err = codec->getStatus();
    }

    erpc_free(name);

    return err;
}

// Server shim for board_aes_encrypt_ecb of test_suite interface.
erpc_status_t test_suite_service::board_aes_encrypt_ecb_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    data_t *key_str = NULL;
    key_str = (data_t *) erpc_malloc(sizeof(data_t));
    if (key_str == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *src_str = NULL;
    src_str = (data_t *) erpc_malloc(sizeof(data_t));
    if (src_str == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *hex_dst_string = NULL;
    hex_dst_string = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_dst_string == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t setkey_result;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_data_t_struct(codec, key_str);

    read_data_t_struct(codec, src_str);

    read_data_t_struct(codec, hex_dst_string);

    codec->read(&setkey_result);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = board_aes_encrypt_ecb(key_str, src_str, hex_dst_string, setkey_result);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, ktest_suite_service_id, ktest_suite_board_aes_encrypt_ecb_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (key_str)
    {
        free_data_t_struct(key_str);
    }
    erpc_free(key_str);

    if (src_str)
    {
        free_data_t_struct(src_str);
    }
    erpc_free(src_str);

    if (hex_dst_string)
    {
        free_data_t_struct(hex_dst_string);
    }
    erpc_free(hex_dst_string);

    return err;
}

// Server shim for board_aes_decrypt_ecb of test_suite interface.
erpc_status_t test_suite_service::board_aes_decrypt_ecb_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    data_t *key_str = NULL;
    key_str = (data_t *) erpc_malloc(sizeof(data_t));
    if (key_str == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *src_str = NULL;
    src_str = (data_t *) erpc_malloc(sizeof(data_t));
    if (src_str == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *hex_dst_string = NULL;
    hex_dst_string = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_dst_string == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t setkey_result;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_data_t_struct(codec, key_str);

    read_data_t_struct(codec, src_str);

    read_data_t_struct(codec, hex_dst_string);

    codec->read(&setkey_result);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = board_aes_decrypt_ecb(key_str, src_str, hex_dst_string, setkey_result);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, ktest_suite_service_id, ktest_suite_board_aes_decrypt_ecb_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (key_str)
    {
        free_data_t_struct(key_str);
    }
    erpc_free(key_str);

    if (src_str)
    {
        free_data_t_struct(src_str);
    }
    erpc_free(src_str);

    if (hex_dst_string)
    {
        free_data_t_struct(hex_dst_string);
    }
    erpc_free(hex_dst_string);

    return err;
}

// Server shim for board_aes_encrypt_cbc of test_suite interface.
erpc_status_t test_suite_service::board_aes_encrypt_cbc_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    data_t *key_str = NULL;
    key_str = (data_t *) erpc_malloc(sizeof(data_t));
    if (key_str == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *iv_str = NULL;
    iv_str = (data_t *) erpc_malloc(sizeof(data_t));
    if (iv_str == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *src_str = NULL;
    src_str = (data_t *) erpc_malloc(sizeof(data_t));
    if (src_str == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *hex_dst_string = NULL;
    hex_dst_string = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_dst_string == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t cbc_result;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_data_t_struct(codec, key_str);

    read_data_t_struct(codec, iv_str);

    read_data_t_struct(codec, src_str);

    read_data_t_struct(codec, hex_dst_string);

    codec->read(&cbc_result);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = board_aes_encrypt_cbc(key_str, iv_str, src_str, hex_dst_string, cbc_result);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, ktest_suite_service_id, ktest_suite_board_aes_encrypt_cbc_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (key_str)
    {
        free_data_t_struct(key_str);
    }
    erpc_free(key_str);

    if (iv_str)
    {
        free_data_t_struct(iv_str);
    }
    erpc_free(iv_str);

    if (src_str)
    {
        free_data_t_struct(src_str);
    }
    erpc_free(src_str);

    if (hex_dst_string)
    {
        free_data_t_struct(hex_dst_string);
    }
    erpc_free(hex_dst_string);

    return err;
}

// Server shim for board_aes_decrypt_cbc of test_suite interface.
erpc_status_t test_suite_service::board_aes_decrypt_cbc_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    data_t *key_str = NULL;
    key_str = (data_t *) erpc_malloc(sizeof(data_t));
    if (key_str == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *iv_str = NULL;
    iv_str = (data_t *) erpc_malloc(sizeof(data_t));
    if (iv_str == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *src_str = NULL;
    src_str = (data_t *) erpc_malloc(sizeof(data_t));
    if (src_str == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *hex_dst_string = NULL;
    hex_dst_string = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_dst_string == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t cbc_result;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_data_t_struct(codec, key_str);

    read_data_t_struct(codec, iv_str);

    read_data_t_struct(codec, src_str);

    read_data_t_struct(codec, hex_dst_string);

    codec->read(&cbc_result);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = board_aes_decrypt_cbc(key_str, iv_str, src_str, hex_dst_string, cbc_result);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, ktest_suite_service_id, ktest_suite_board_aes_decrypt_cbc_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (key_str)
    {
        free_data_t_struct(key_str);
    }
    erpc_free(key_str);

    if (iv_str)
    {
        free_data_t_struct(iv_str);
    }
    erpc_free(iv_str);

    if (src_str)
    {
        free_data_t_struct(src_str);
    }
    erpc_free(src_str);

    if (hex_dst_string)
    {
        free_data_t_struct(hex_dst_string);
    }
    erpc_free(hex_dst_string);

    return err;
}

// Server shim for board_aes_encrypt_cfb128 of test_suite interface.
erpc_status_t test_suite_service::board_aes_encrypt_cfb128_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    data_t *key_str = NULL;
    key_str = (data_t *) erpc_malloc(sizeof(data_t));
    if (key_str == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *iv_str = NULL;
    iv_str = (data_t *) erpc_malloc(sizeof(data_t));
    if (iv_str == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *src_str = NULL;
    src_str = (data_t *) erpc_malloc(sizeof(data_t));
    if (src_str == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *hex_dst_string = NULL;
    hex_dst_string = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_dst_string == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_data_t_struct(codec, key_str);

    read_data_t_struct(codec, iv_str);

    read_data_t_struct(codec, src_str);

    read_data_t_struct(codec, hex_dst_string);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = board_aes_encrypt_cfb128(key_str, iv_str, src_str, hex_dst_string);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, ktest_suite_service_id, ktest_suite_board_aes_encrypt_cfb128_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (key_str)
    {
        free_data_t_struct(key_str);
    }
    erpc_free(key_str);

    if (iv_str)
    {
        free_data_t_struct(iv_str);
    }
    erpc_free(iv_str);

    if (src_str)
    {
        free_data_t_struct(src_str);
    }
    erpc_free(src_str);

    if (hex_dst_string)
    {
        free_data_t_struct(hex_dst_string);
    }
    erpc_free(hex_dst_string);

    return err;
}

// Server shim for board_aes_decrypt_cfb128 of test_suite interface.
erpc_status_t test_suite_service::board_aes_decrypt_cfb128_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    data_t *key_str = NULL;
    key_str = (data_t *) erpc_malloc(sizeof(data_t));
    if (key_str == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *iv_str = NULL;
    iv_str = (data_t *) erpc_malloc(sizeof(data_t));
    if (iv_str == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *src_str = NULL;
    src_str = (data_t *) erpc_malloc(sizeof(data_t));
    if (src_str == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *hex_dst_string = NULL;
    hex_dst_string = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_dst_string == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_data_t_struct(codec, key_str);

    read_data_t_struct(codec, iv_str);

    read_data_t_struct(codec, src_str);

    read_data_t_struct(codec, hex_dst_string);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = board_aes_decrypt_cfb128(key_str, iv_str, src_str, hex_dst_string);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, ktest_suite_service_id, ktest_suite_board_aes_decrypt_cfb128_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (key_str)
    {
        free_data_t_struct(key_str);
    }
    erpc_free(key_str);

    if (iv_str)
    {
        free_data_t_struct(iv_str);
    }
    erpc_free(iv_str);

    if (src_str)
    {
        free_data_t_struct(src_str);
    }
    erpc_free(src_str);

    if (hex_dst_string)
    {
        free_data_t_struct(hex_dst_string);
    }
    erpc_free(hex_dst_string);

    return err;
}

// Server shim for board_aes_encrypt_cfb8 of test_suite interface.
erpc_status_t test_suite_service::board_aes_encrypt_cfb8_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    data_t *key_str = NULL;
    key_str = (data_t *) erpc_malloc(sizeof(data_t));
    if (key_str == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *iv_str = NULL;
    iv_str = (data_t *) erpc_malloc(sizeof(data_t));
    if (iv_str == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *src_str = NULL;
    src_str = (data_t *) erpc_malloc(sizeof(data_t));
    if (src_str == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *hex_dst_string = NULL;
    hex_dst_string = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_dst_string == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_data_t_struct(codec, key_str);

    read_data_t_struct(codec, iv_str);

    read_data_t_struct(codec, src_str);

    read_data_t_struct(codec, hex_dst_string);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = board_aes_encrypt_cfb8(key_str, iv_str, src_str, hex_dst_string);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, ktest_suite_service_id, ktest_suite_board_aes_encrypt_cfb8_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (key_str)
    {
        free_data_t_struct(key_str);
    }
    erpc_free(key_str);

    if (iv_str)
    {
        free_data_t_struct(iv_str);
    }
    erpc_free(iv_str);

    if (src_str)
    {
        free_data_t_struct(src_str);
    }
    erpc_free(src_str);

    if (hex_dst_string)
    {
        free_data_t_struct(hex_dst_string);
    }
    erpc_free(hex_dst_string);

    return err;
}

// Server shim for board_aes_decrypt_cfb8 of test_suite interface.
erpc_status_t test_suite_service::board_aes_decrypt_cfb8_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    data_t *key_str = NULL;
    key_str = (data_t *) erpc_malloc(sizeof(data_t));
    if (key_str == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *iv_str = NULL;
    iv_str = (data_t *) erpc_malloc(sizeof(data_t));
    if (iv_str == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *src_str = NULL;
    src_str = (data_t *) erpc_malloc(sizeof(data_t));
    if (src_str == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *hex_dst_string = NULL;
    hex_dst_string = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_dst_string == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_data_t_struct(codec, key_str);

    read_data_t_struct(codec, iv_str);

    read_data_t_struct(codec, src_str);

    read_data_t_struct(codec, hex_dst_string);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = board_aes_decrypt_cfb8(key_str, iv_str, src_str, hex_dst_string);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, ktest_suite_service_id, ktest_suite_board_aes_decrypt_cfb8_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (key_str)
    {
        free_data_t_struct(key_str);
    }
    erpc_free(key_str);

    if (iv_str)
    {
        free_data_t_struct(iv_str);
    }
    erpc_free(iv_str);

    if (src_str)
    {
        free_data_t_struct(src_str);
    }
    erpc_free(src_str);

    if (hex_dst_string)
    {
        free_data_t_struct(hex_dst_string);
    }
    erpc_free(hex_dst_string);

    return err;
}

// Server shim for board_mbedtls_aes_self_test of test_suite interface.
erpc_status_t test_suite_service::board_mbedtls_aes_self_test_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t verbose;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&verbose);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = board_mbedtls_aes_self_test(verbose);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, ktest_suite_service_id, ktest_suite_board_mbedtls_aes_self_test_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for board_des_check_weak of test_suite interface.
erpc_status_t test_suite_service::board_des_check_weak_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    data_t *key = NULL;
    key = (data_t *) erpc_malloc(sizeof(data_t));
    if (key == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t ret;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_data_t_struct(codec, key);

    codec->read(&ret);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = board_des_check_weak(key, ret);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, ktest_suite_service_id, ktest_suite_board_des_check_weak_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (key)
    {
        free_data_t_struct(key);
    }
    erpc_free(key);

    return err;
}

// Server shim for board_des_encrypt_ecb of test_suite interface.
erpc_status_t test_suite_service::board_des_encrypt_ecb_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    data_t *hex_key = NULL;
    hex_key = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_key == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *hex_src = NULL;
    hex_src = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_src == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *hex_dst = NULL;
    hex_dst = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_dst == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_data_t_struct(codec, hex_key);

    read_data_t_struct(codec, hex_src);

    read_data_t_struct(codec, hex_dst);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = board_des_encrypt_ecb(hex_key, hex_src, hex_dst);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, ktest_suite_service_id, ktest_suite_board_des_encrypt_ecb_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (hex_key)
    {
        free_data_t_struct(hex_key);
    }
    erpc_free(hex_key);

    if (hex_src)
    {
        free_data_t_struct(hex_src);
    }
    erpc_free(hex_src);

    if (hex_dst)
    {
        free_data_t_struct(hex_dst);
    }
    erpc_free(hex_dst);

    return err;
}

// Server shim for board_des_decrypt_ecb of test_suite interface.
erpc_status_t test_suite_service::board_des_decrypt_ecb_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    data_t *hex_key = NULL;
    hex_key = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_key == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *hex_src = NULL;
    hex_src = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_src == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *hex_dst = NULL;
    hex_dst = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_dst == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_data_t_struct(codec, hex_key);

    read_data_t_struct(codec, hex_src);

    read_data_t_struct(codec, hex_dst);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = board_des_decrypt_ecb(hex_key, hex_src, hex_dst);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, ktest_suite_service_id, ktest_suite_board_des_decrypt_ecb_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (hex_key)
    {
        free_data_t_struct(hex_key);
    }
    erpc_free(hex_key);

    if (hex_src)
    {
        free_data_t_struct(hex_src);
    }
    erpc_free(hex_src);

    if (hex_dst)
    {
        free_data_t_struct(hex_dst);
    }
    erpc_free(hex_dst);

    return err;
}

// Server shim for board_des_encrypt_cbc of test_suite interface.
erpc_status_t test_suite_service::board_des_encrypt_cbc_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    data_t *hex_key = NULL;
    hex_key = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_key == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *hex_iv = NULL;
    hex_iv = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_iv == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *hex_src = NULL;
    hex_src = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_src == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *hex_dst = NULL;
    hex_dst = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_dst == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t cbc_result;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_data_t_struct(codec, hex_key);

    read_data_t_struct(codec, hex_iv);

    read_data_t_struct(codec, hex_src);

    read_data_t_struct(codec, hex_dst);

    codec->read(&cbc_result);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = board_des_encrypt_cbc(hex_key, hex_iv, hex_src, hex_dst, cbc_result);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, ktest_suite_service_id, ktest_suite_board_des_encrypt_cbc_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (hex_key)
    {
        free_data_t_struct(hex_key);
    }
    erpc_free(hex_key);

    if (hex_iv)
    {
        free_data_t_struct(hex_iv);
    }
    erpc_free(hex_iv);

    if (hex_src)
    {
        free_data_t_struct(hex_src);
    }
    erpc_free(hex_src);

    if (hex_dst)
    {
        free_data_t_struct(hex_dst);
    }
    erpc_free(hex_dst);

    return err;
}

// Server shim for board_des_decrypt_cbc of test_suite interface.
erpc_status_t test_suite_service::board_des_decrypt_cbc_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    data_t *hex_key = NULL;
    hex_key = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_key == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *hex_iv = NULL;
    hex_iv = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_iv == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *hex_src = NULL;
    hex_src = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_src == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *hex_dst = NULL;
    hex_dst = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_dst == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t cbc_result;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_data_t_struct(codec, hex_key);

    read_data_t_struct(codec, hex_iv);

    read_data_t_struct(codec, hex_src);

    read_data_t_struct(codec, hex_dst);

    codec->read(&cbc_result);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = board_des_decrypt_cbc(hex_key, hex_iv, hex_src, hex_dst, cbc_result);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, ktest_suite_service_id, ktest_suite_board_des_decrypt_cbc_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (hex_key)
    {
        free_data_t_struct(hex_key);
    }
    erpc_free(hex_key);

    if (hex_iv)
    {
        free_data_t_struct(hex_iv);
    }
    erpc_free(hex_iv);

    if (hex_src)
    {
        free_data_t_struct(hex_src);
    }
    erpc_free(hex_src);

    if (hex_dst)
    {
        free_data_t_struct(hex_dst);
    }
    erpc_free(hex_dst);

    return err;
}

// Server shim for board_des3_encrypt_ecb of test_suite interface.
erpc_status_t test_suite_service::board_des3_encrypt_ecb_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t key_count;
    data_t *hex_key = NULL;
    hex_key = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_key == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *hex_src = NULL;
    hex_src = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_src == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *hex_dst = NULL;
    hex_dst = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_dst == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&key_count);

    read_data_t_struct(codec, hex_key);

    read_data_t_struct(codec, hex_src);

    read_data_t_struct(codec, hex_dst);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = board_des3_encrypt_ecb(key_count, hex_key, hex_src, hex_dst);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, ktest_suite_service_id, ktest_suite_board_des3_encrypt_ecb_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (hex_key)
    {
        free_data_t_struct(hex_key);
    }
    erpc_free(hex_key);

    if (hex_src)
    {
        free_data_t_struct(hex_src);
    }
    erpc_free(hex_src);

    if (hex_dst)
    {
        free_data_t_struct(hex_dst);
    }
    erpc_free(hex_dst);

    return err;
}

// Server shim for board_des3_decrypt_ecb of test_suite interface.
erpc_status_t test_suite_service::board_des3_decrypt_ecb_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t key_count;
    data_t *hex_key = NULL;
    hex_key = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_key == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *hex_src = NULL;
    hex_src = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_src == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *hex_dst = NULL;
    hex_dst = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_dst == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&key_count);

    read_data_t_struct(codec, hex_key);

    read_data_t_struct(codec, hex_src);

    read_data_t_struct(codec, hex_dst);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = board_des3_decrypt_ecb(key_count, hex_key, hex_src, hex_dst);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, ktest_suite_service_id, ktest_suite_board_des3_decrypt_ecb_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (hex_key)
    {
        free_data_t_struct(hex_key);
    }
    erpc_free(hex_key);

    if (hex_src)
    {
        free_data_t_struct(hex_src);
    }
    erpc_free(hex_src);

    if (hex_dst)
    {
        free_data_t_struct(hex_dst);
    }
    erpc_free(hex_dst);

    return err;
}

// Server shim for board_des3_encrypt_cbc of test_suite interface.
erpc_status_t test_suite_service::board_des3_encrypt_cbc_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t key_count;
    data_t *hex_key = NULL;
    hex_key = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_key == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *hex_iv = NULL;
    hex_iv = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_iv == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *hex_src = NULL;
    hex_src = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_src == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *hex_dst = NULL;
    hex_dst = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_dst == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t cbc_result;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&key_count);

    read_data_t_struct(codec, hex_key);

    read_data_t_struct(codec, hex_iv);

    read_data_t_struct(codec, hex_src);

    read_data_t_struct(codec, hex_dst);

    codec->read(&cbc_result);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = board_des3_encrypt_cbc(key_count, hex_key, hex_iv, hex_src, hex_dst, cbc_result);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, ktest_suite_service_id, ktest_suite_board_des3_encrypt_cbc_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (hex_key)
    {
        free_data_t_struct(hex_key);
    }
    erpc_free(hex_key);

    if (hex_iv)
    {
        free_data_t_struct(hex_iv);
    }
    erpc_free(hex_iv);

    if (hex_src)
    {
        free_data_t_struct(hex_src);
    }
    erpc_free(hex_src);

    if (hex_dst)
    {
        free_data_t_struct(hex_dst);
    }
    erpc_free(hex_dst);

    return err;
}

// Server shim for board_des3_decrypt_cbc of test_suite interface.
erpc_status_t test_suite_service::board_des3_decrypt_cbc_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t key_count;
    data_t *hex_key = NULL;
    hex_key = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_key == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *hex_iv = NULL;
    hex_iv = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_iv == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *hex_src = NULL;
    hex_src = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_src == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *hex_dst = NULL;
    hex_dst = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_dst == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t cbc_result;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&key_count);

    read_data_t_struct(codec, hex_key);

    read_data_t_struct(codec, hex_iv);

    read_data_t_struct(codec, hex_src);

    read_data_t_struct(codec, hex_dst);

    codec->read(&cbc_result);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = board_des3_decrypt_cbc(key_count, hex_key, hex_iv, hex_src, hex_dst, cbc_result);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, ktest_suite_service_id, ktest_suite_board_des3_decrypt_cbc_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (hex_key)
    {
        free_data_t_struct(hex_key);
    }
    erpc_free(hex_key);

    if (hex_iv)
    {
        free_data_t_struct(hex_iv);
    }
    erpc_free(hex_iv);

    if (hex_src)
    {
        free_data_t_struct(hex_src);
    }
    erpc_free(hex_src);

    if (hex_dst)
    {
        free_data_t_struct(hex_dst);
    }
    erpc_free(hex_dst);

    return err;
}

// Server shim for board_des_key_parity_run of test_suite interface.
erpc_status_t test_suite_service::board_des_key_parity_run_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = board_des_key_parity_run();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, ktest_suite_service_id, ktest_suite_board_des_key_parity_run_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for board_mbedtls_des_self_test of test_suite interface.
erpc_status_t test_suite_service::board_mbedtls_des_self_test_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t verbose;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&verbose);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = board_mbedtls_des_self_test(verbose);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, ktest_suite_service_id, ktest_suite_board_mbedtls_des_self_test_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for board_mbedtls_sha1 of test_suite interface.
erpc_status_t test_suite_service::board_mbedtls_sha1_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    data_t *src_str = NULL;
    src_str = (data_t *) erpc_malloc(sizeof(data_t));
    if (src_str == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *hex_hash_string = NULL;
    hex_hash_string = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_hash_string == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_data_t_struct(codec, src_str);

    read_data_t_struct(codec, hex_hash_string);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = board_mbedtls_sha1(src_str, hex_hash_string);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, ktest_suite_service_id, ktest_suite_board_mbedtls_sha1_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (src_str)
    {
        free_data_t_struct(src_str);
    }
    erpc_free(src_str);

    if (hex_hash_string)
    {
        free_data_t_struct(hex_hash_string);
    }
    erpc_free(hex_hash_string);

    return err;
}

// Server shim for board_sha224 of test_suite interface.
erpc_status_t test_suite_service::board_sha224_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    data_t *src_str = NULL;
    src_str = (data_t *) erpc_malloc(sizeof(data_t));
    if (src_str == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *hex_hash_string = NULL;
    hex_hash_string = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_hash_string == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_data_t_struct(codec, src_str);

    read_data_t_struct(codec, hex_hash_string);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = board_sha224(src_str, hex_hash_string);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, ktest_suite_service_id, ktest_suite_board_sha224_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (src_str)
    {
        free_data_t_struct(src_str);
    }
    erpc_free(src_str);

    if (hex_hash_string)
    {
        free_data_t_struct(hex_hash_string);
    }
    erpc_free(hex_hash_string);

    return err;
}

// Server shim for board_mbedtls_sha256 of test_suite interface.
erpc_status_t test_suite_service::board_mbedtls_sha256_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    data_t *src_str = NULL;
    src_str = (data_t *) erpc_malloc(sizeof(data_t));
    if (src_str == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *hex_hash_string = NULL;
    hex_hash_string = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_hash_string == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_data_t_struct(codec, src_str);

    read_data_t_struct(codec, hex_hash_string);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = board_mbedtls_sha256(src_str, hex_hash_string);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, ktest_suite_service_id, ktest_suite_board_mbedtls_sha256_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (src_str)
    {
        free_data_t_struct(src_str);
    }
    erpc_free(src_str);

    if (hex_hash_string)
    {
        free_data_t_struct(hex_hash_string);
    }
    erpc_free(hex_hash_string);

    return err;
}

// Server shim for board_sha384 of test_suite interface.
erpc_status_t test_suite_service::board_sha384_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    data_t *src_str = NULL;
    src_str = (data_t *) erpc_malloc(sizeof(data_t));
    if (src_str == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *hex_hash_string = NULL;
    hex_hash_string = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_hash_string == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_data_t_struct(codec, src_str);

    read_data_t_struct(codec, hex_hash_string);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = board_sha384(src_str, hex_hash_string);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, ktest_suite_service_id, ktest_suite_board_sha384_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (src_str)
    {
        free_data_t_struct(src_str);
    }
    erpc_free(src_str);

    if (hex_hash_string)
    {
        free_data_t_struct(hex_hash_string);
    }
    erpc_free(hex_hash_string);

    return err;
}

// Server shim for board_mbedtls_sha512 of test_suite interface.
erpc_status_t test_suite_service::board_mbedtls_sha512_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    data_t *src_str = NULL;
    src_str = (data_t *) erpc_malloc(sizeof(data_t));
    if (src_str == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    data_t *hex_hash_string = NULL;
    hex_hash_string = (data_t *) erpc_malloc(sizeof(data_t));
    if (hex_hash_string == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_data_t_struct(codec, src_str);

    read_data_t_struct(codec, hex_hash_string);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = board_mbedtls_sha512(src_str, hex_hash_string);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, ktest_suite_service_id, ktest_suite_board_mbedtls_sha512_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (src_str)
    {
        free_data_t_struct(src_str);
    }
    erpc_free(src_str);

    if (hex_hash_string)
    {
        free_data_t_struct(hex_hash_string);
    }
    erpc_free(hex_hash_string);

    return err;
}

// Server shim for board_sha1_selftest of test_suite interface.
erpc_status_t test_suite_service::board_sha1_selftest_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t verbose;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&verbose);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = board_sha1_selftest(verbose);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, ktest_suite_service_id, ktest_suite_board_sha1_selftest_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for board_sha256_selftest of test_suite interface.
erpc_status_t test_suite_service::board_sha256_selftest_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t verbose;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&verbose);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = board_sha256_selftest(verbose);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, ktest_suite_service_id, ktest_suite_board_sha256_selftest_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for board_sha512_selftest of test_suite interface.
erpc_status_t test_suite_service::board_sha512_selftest_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t verbose;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&verbose);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = board_sha512_selftest(verbose);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, ktest_suite_service_id, ktest_suite_board_sha512_selftest_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

erpc_service_t create_test_suite_service(void)
{
    erpc_service_t service;

#if ERPC_ALLOCATION_POLICY == ERPC_ALLOCATION_POLICY_DYNAMIC
    service = new (nothrow) test_suite_service();
#else
    if (s_test_suite_service.isUsed())
    {
        service = NULL;
    }
    else
    {
        s_test_suite_service.construct();
        service = s_test_suite_service.get();
    }
#endif

    return service;
}

void destroy_test_suite_service(erpc_service_t service)
{
#if ERPC_ALLOCATION_POLICY == ERPC_ALLOCATION_POLICY_DYNAMIC
    erpc_assert(service != NULL);
    delete (test_suite_service *)service;
#else
    (void)service;
    erpc_assert(service == s_test_suite_service.get());
    s_test_suite_service.destroy();
#endif
}

