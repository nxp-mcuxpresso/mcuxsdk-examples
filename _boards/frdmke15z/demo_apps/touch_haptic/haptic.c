/*
 * The Clear BSD License
 * Copyright (c) 2013 - 2016, Freescale Semiconductor, Inc.
 * Copyright 2016-2014 NXP
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted (subject to the limitations in the disclaimer below) provided
 * that the following conditions are met:
 *
 * o Redistributions of source code must retain the above copyright notice, this list
 *   of conditions and the following disclaimer.
 *
 * o Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 *
 * o Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from this
 *   software without specific prior written permission.
 *
 * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 /*
 Static configuration c file for the NXP Touch Library
 generated by the NXP Touch GUI Tool
*/

#include "haptic.h"
#include "fix_lib.h"
#include "main.h"
#include "audiohaptic_sigs.h"
#include "haptic_pwm.h"

/*******************************************************************************
 * Definitions
 ******************************************************************************/

/* Define digital output scaling:
 * Digital "1" times output gain should correspond to analog 5[V]
 * Example for 15dB amplifier: 5[V]/db2mag(15dB) to int16_t (0.889139705019461*32767) = 29134
 */
/* PWM H-Bridge output gain scale level*/
#define HAP_AMP_OUT_GAIN (32767)

/* Define haptic sequencer pattern size: used for double click */
#define HAP_MAX_SEQUENCE_LEN  (2)

/* I2S Audio buffer vars */
#define HAP_CH_BUF_SIZE     (256)
#define HAP_I2S_BUF_SIZE    (HAP_CH_BUF_SIZE*HAP_N_CH)   /* Size of PCM out buffers */

/* I2S sine-wave parameters */
#define HAPTIC_SIN_FREQ     (160)
/* Add rounding */
#define HAPTIC_SIN_SAMPLES  (HAPTIC_FS / HAPTIC_SIN_FREQ)
#define HAPTIC_SIN_AMP      (0.12)

/* 250ms fadeIn: alpha = exp( -1/fs/0.250 ) */
#define HAP_PROMPT_FADE_IN_ALPHA   (0.999750031247396)
/* 5ms fadeOut: alpha = exp( -1/fs/0.005 ) */
#define HAP_PROMPT_FADE_OUT_ALPHA  (0.987577800493881)

/* Multiply int16_t fixed-point numbers */
#define MULT_INT16(a,b) ( (int16_t) ( ( ( (int32_t)( (int16_t)(a) ) * (int16_t)(b) ) << 1 ) >> 16 ) )
/* Add and saturate int16_t fixed-point numbers */
#define ADD_SAT_INT16(a,b) ( (int16_t) FIX_CLIP( ( (int32_t)(a) + (int32_t)(b) ), -32768, 32767) )

/*******************************************************************************
 * Types
 ******************************************************************************/

typedef struct _wav_data_t
{
    const int16_t* data;              /*!< PCM sample data */
    uint32_t size;                    /*!< size in 16-bit samples*/
} wav_data_t;

typedef struct _wav_haptic_t
{
    const wav_data_t* audio;
    const wav_data_t* haptic;
} wav_haptic_t;

typedef struct _haptic_element_t
{
    haptic_trigger_en id;
    haptic_effect_t* pEffect;
    int32_t cHaptic[HAP_N_CH];
    int32_t cSmp;
    uint8_t isBusy;
} haptic_element_t;

typedef struct _haptic_sequence_t
{
    haptic_element_t element[HAP_MAX_SEQUENCE_LEN];
    uint8_t isBusy;
} haptic_sequence_t;

typedef struct _haptic_state_t
{
    int16_t buf1[HAP_I2S_BUF_SIZE]; /*!< first audio buffer */
    int16_t buf2[HAP_I2S_BUF_SIZE]; /*!< second audio buffer */
    int16_t* pPlayBuf;              /*!< pointer to playback buffer */
    int16_t* pFreeBuf;              /*!< pointer to free buffer */
    fxl_sin_t promptSinBase;        /*!< base prompt sine-wave */
    fxl_sin_t promptSinMod ;        /*!< modulation prompt sine-wave */
    fxl_asym_smooth_t promptLpf;    /*!< fadeIn/fadeOut filter */
    fix_t promptPhaseIncLong;       /*!< Long press */
    fix_t promptGain;
    /* Haptic stream elements */
    haptic_element_t  hapClick;
    haptic_sequence_t hapSequence;
    /* Tone lookup table*/
    fix_t* sinTable;
    size_t sinLen;
    size_t cSin;
    /* Audio haptic flags*/
    uint8_t hapticsOn;
    uint8_t audioOn;
    uint16_t audioGain;
    uint32_t pwmCallbackFlag;
} haptic_state_t;

/*******************************************************************************
 * Variables
 ******************************************************************************/

wav_haptic_t wavAudioHaptic[HAPTIC_TRIGGER_LAST];

const wav_data_t wavHapticDefault = {
    .data = (const int16_t*)&sig_haptic,
    .size = sizeof(sig_haptic) >> 1,
};

const wav_data_t wavAudioPress = {
    .data = (const int16_t*)&sig_audio_press,
    .size = sizeof(sig_audio_press) >> 1,
};

const wav_data_t wavAudioRelease = {
    .data = (const int16_t*)&sig_audio_release,
    .size = sizeof(sig_audio_release) >> 1,
};

const wav_data_t wavAudioAutoRepeat = {
    .data = (const int16_t*)&sig_audio_autoRepeat,
    .size = sizeof(sig_audio_autoRepeat) >> 1,
};

const wav_data_t wavAudioIntro = {
    .data = (const int16_t*)&sig_audio_intro,
    .size = sizeof(sig_audio_intro) >> 1,
};

const wav_data_t wavAudioBeep = {
    .data = (const int16_t*)&sig_audio_beep,
    .size = sizeof(sig_audio_beep) >> 1,
};

/* Tone look-up table storage */
static fix_t gSinTable[HAPTIC_SIN_SAMPLES];

/* Haptic state storage */
static haptic_state_t hapticState = { 0 };
static haptic_state_t* pS = &hapticState;

/*******************************************************************************
 * Prototypes
 ******************************************************************************/

/*******************************************************************************
 * Private functions
 ******************************************************************************/

void haptic_swap_buffers( void )
{
    /* swap free/play buffer pointers */
    int16_t* tmp = pS->pPlayBuf;
    pS->pPlayBuf = pS->pFreeBuf;
    pS->pFreeBuf = tmp;
}

void haptic_init_prompt( void )
{
    fix_t sinAmp1   = DOUBLE_TO_FIX_EXP(HAPTIC_SIN_AMP , 0 );
    fix_t phaseInc1 = FXL_SIN_PHASE_INC(HAPTIC_SIN_FREQ, HAPTIC_FS);
    fix_t sinAmp2   = FIXT_MAX;
    fix_t phaseInc2 = pS->promptPhaseIncLong;
    fix_t phaseInit = 0;
    fxl_sin_init(&pS->promptSinBase, phaseInc1, sinAmp1, phaseInit);
    fxl_sin_init(&pS->promptSinMod , phaseInc2, sinAmp2, phaseInit);
    /* FadeIn/fadeOut amplitude low-pass filter */
    fix_t lpfAlpfaUp = DOUBLE_TO_FIX_EXP(HAP_PROMPT_FADE_IN_ALPHA , FXL_LPF_ALPHA_EXP);
    fix_t lpfAlpfaDn = DOUBLE_TO_FIX_EXP(HAP_PROMPT_FADE_OUT_ALPHA, FXL_LPF_ALPHA_EXP);
    fix_t lpfInit  = 0;
    fxl_asym_smooth_init(&pS->promptLpf, lpfAlpfaUp, lpfAlpfaDn, lpfInit);

    phaseInc1 = FXL_SIN_PHASE_INC(HAPTIC_FS / pS->sinLen, HAPTIC_FS);
    phaseInit = 0;
    for( size_t c1 = 0; c1 < pS->sinLen; c1++ )
    {
        pS->sinTable[c1] = fxl_sin_process( &pS->promptSinBase );
    }
}

void haptic_generate_prompt( int16_t* pData )
{
    size_t cSmp = 0, cCh = 0;
    fix_t sin1, sin2, fadeGain, sinFix;
    fix_t promptGain = ( pS->hapticsOn == 1 ) ? pS->promptGain : 0;

    /* Sine target gain or fadeOut gain above 0 */
    if( promptGain > 0 || pS->promptLpf.y1 > 0 )
    {
        for( cSmp = 0; cSmp < HAP_I2S_BUF_SIZE; cSmp+=HAP_N_CH )
        {
            /* Sine generator */
            sin1 = pS->sinTable[pS->cSin++];
            if( pS->cSin >= pS->sinLen )
            {
                pS->cSin = 0;
            }
            sin2 = fxl_sin_process( &pS->promptSinMod );
            /* Sine faideIn/fadeOut lpf */
            fadeGain = fxl_asym_smooth_process(&pS->promptLpf, promptGain);
            /* sinFix = sin1 * sin2 */
            sinFix = MUL_FIX_EXP(sin1, 0, sin2, 0, 0);
            /* sinFix * toneGain */
            sinFix = MUL_FIX_EXP(sinFix, 0, fadeGain, 0, 0);
            /* fix_t to int16_t */
            sinFix = sinFix >> (FIX_W_SZ - 16);

            for( cCh = 0; cCh < HAP_N_CH; cCh+=1 )
            {
                pData[cSmp+cCh] = ADD_SAT_INT16(sinFix, pData[cSmp+cCh]);
            }
        }
    }
}

void haptic_generate_click( haptic_element_t* pElement, int16_t* pData )
{
    const wav_data_t* pWavAudio = wavAudioHaptic[pElement->id].audio;
    const wav_data_t* pWavHaptic = wavAudioHaptic[pElement->id].haptic;
    size_t cSmp = 0, cCh = 0;
    int32_t tmp[HAP_N_CH] = {0};
    int16_t hapGain = ( pS->hapticsOn == 1 ) ? pElement->pEffect->gain    : 0;
    int16_t audGain = (   pS->audioOn == 1 ) ? pS->audioGain              : 0;

    if( pElement->isBusy )
    {
        for( cSmp = 0; cSmp < HAP_I2S_BUF_SIZE; cSmp+=HAP_N_CH )
        {
            if( pElement->cSmp >= 0 )
            {
                for( cCh = 0; cCh < HAP_N_CH; cCh+=1 )
                {
                    /* HAPTICS */
                    tmp[cCh] = 0;
                    /* Delay finished and data not finished ? */
                    if(   pElement->cHaptic[cCh] >= 0
                       && pElement->cHaptic[cCh] < pWavHaptic->size)
                    {
                        /* Start adding click to channel */
                        tmp[cCh] = MULT_INT16( pWavHaptic->data[ pElement->cHaptic[cCh] ], hapGain );
                    }
                    ++pElement->cHaptic[cCh];
                    /* AUDIO */
                    if(   pElement->cSmp >= 0
                       && pElement->cSmp < pWavAudio->size )
                    {
                        tmp[cCh] = tmp[cCh] + ( pWavAudio->data[ pElement->cSmp ] ) * audGain;
                    }
                    /* OUTPUT */
                    pData[cSmp+cCh] = ADD_SAT_INT16(tmp[cCh], pData[cSmp+cCh]);
                }
            }
            ++pElement->cSmp;
        }

        /* Audio is finished check */
        pElement->isBusy = pElement->cSmp < pWavAudio->size;

        /* Haptic channels finished check */
        for ( cCh = 0; cCh < HAP_N_CH; cCh++ )
        {
            pElement->isBusy |= (pElement->cHaptic[cCh] < pWavHaptic->size);
        }

    }
}

void haptic_generate_sequence( haptic_sequence_t* pSequence, int16_t* pData  )
{
    size_t cSeq = 0;
    if( pSequence->isBusy )
    {
        pSequence->isBusy = 0;
        for( cSeq = 0; cSeq < HAP_MAX_SEQUENCE_LEN; ++cSeq )
        {
            haptic_generate_click( &pSequence->element[cSeq], pData );
            /* Is any element busy */
            pSequence->isBusy |= pSequence->element[cSeq].isBusy;
        }
    }
}

static void haptic_start_click( haptic_element_t* pElement, haptic_trigger_en id, haptic_effect_t* pEffect, int32_t startDelay )
{
#if (NT_FRDM_HAPTIC_SUPPORT == 1)     
    /* Is trigger id valid? */
    if ( pElement->isBusy == 0 )
    {
        pElement->isBusy = 1;
        pElement->id = id;
        pElement->pEffect = pEffect;
        pElement->cSmp = -startDelay;
        for ( size_t c1 = 0; c1 < HAP_N_CH; ++ c1 )
        {
            /* Set haptic delay for each channel */
            pElement->cHaptic[c1] = pEffect->delay[c1];
        }
    }
#endif
}


void haptic_callback_pwm( void )
{
    /* If hatpic main loop not finished add additional buffer.
       Keeps driver playback and haptic_main free buffers separate */
    pS->pwmCallbackFlag = (pS->pwmCallbackFlag + 1) % 3;
}

/*******************************************************************************
 * Public functions
 ******************************************************************************/

void haptic_init( void )
{
    /* Order wav records in predefined order */
    wavAudioHaptic[HAPTIC_TRIGGER_PRESS].audio       = &wavAudioPress;
    wavAudioHaptic[HAPTIC_TRIGGER_PRESS].haptic      = &wavHapticDefault;

    wavAudioHaptic[HAPTIC_TRIGGER_RELEASE].audio     = &wavAudioRelease;
    wavAudioHaptic[HAPTIC_TRIGGER_RELEASE].haptic    = &wavHapticDefault;

    wavAudioHaptic[HAPTIC_TRIGGER_AUTOREPEAT].audio  = &wavAudioAutoRepeat;
    wavAudioHaptic[HAPTIC_TRIGGER_AUTOREPEAT].haptic = &wavHapticDefault;

    wavAudioHaptic[HAPTIC_TRIGGER_INTRO].audio       = &wavAudioIntro;
    wavAudioHaptic[HAPTIC_TRIGGER_INTRO].haptic      = &wavHapticDefault;

    wavAudioHaptic[HAPTIC_TRIGGER_BEEP].audio        = &wavAudioBeep;
    wavAudioHaptic[HAPTIC_TRIGGER_BEEP].haptic       = &wavHapticDefault;

    /* Init state */
    pS->pPlayBuf = pS->buf1;
    pS->pFreeBuf = pS->buf2;
    pS->promptGain        = 0;
    /* Sin look-up table */
    pS->sinTable           = gSinTable;
    pS->sinLen             = HAPTIC_SIN_SAMPLES;
    pS->cSin               = 0;
    /* Enable audio and haptics */
    pS->hapticsOn         = 1;
    pS->audioOn           = 1;
    /* Needed to clip audio for beeps, multiplies all audio gain by X */
    pS->audioGain         = 3;

    /* Init prompt configuration */
    haptic_init_prompt();
    haptic_pwm_init( haptic_callback_pwm );
    pS->pwmCallbackFlag = 0;
    /* Start streaming */
    haptic_pwm_send( (uint8_t *) pS->pPlayBuf, HAP_I2S_BUF_SIZE*sizeof( int16_t ) );
    haptic_pwm_send( (uint8_t *) pS->pFreeBuf, HAP_I2S_BUF_SIZE*sizeof( int16_t ) );
}

void haptic_trigger_click( haptic_trigger_en id, haptic_effect_t* pEffect )
{
    if( id < HAPTIC_TRIGGER_LAST )
    {
        haptic_start_click( &pS->hapClick, id, pEffect, 0 );
    }
}

void haptic_trigger_double_click( haptic_trigger_en id, haptic_effect_t* pEffect, int32_t delay )
{
    if ( pS->hapSequence.isBusy == 0 && id < HAPTIC_TRIGGER_LAST )
    {
        pS->hapSequence.isBusy = 1;
        haptic_start_click( &pS->hapSequence.element[0], id, pEffect, 0 );
        haptic_start_click( &pS->hapSequence.element[1], id, pEffect, delay );
    }
}

void haptic_main( void )
{
    size_t c1 = 0;
    if( haptic_pwm_callback_ready() > 0 )
    {
        haptic_swap_buffers( );
        memset( (void *)pS->pFreeBuf, 0, sizeof(pS->buf1) );
        haptic_generate_click( &pS->hapClick, (int16_t *) pS->pFreeBuf );
        haptic_generate_sequence( &pS->hapSequence, (int16_t *) pS->pFreeBuf  );
        haptic_generate_prompt( (int16_t *) pS->pFreeBuf );
        /* Scale [-1 1] to amplifier clipping level: example [-0.9 0.9] */
        for( c1 = 0; c1 < HAP_I2S_BUF_SIZE; ++c1 )
        {
            pS->pFreeBuf[c1] = MULT_INT16( pS->pFreeBuf[c1], HAP_AMP_OUT_GAIN );
        }
        haptic_pwm_send( (uint8_t *) pS->pFreeBuf, HAP_I2S_BUF_SIZE*sizeof( int16_t ) );
    }
}

void haptic_enable_haptic( uint8_t flagOn )
{
    pS->hapticsOn = ( flagOn > 0 );
}

void haptic_enable_audio( uint8_t flagOn )
{
    pS->audioOn = ( flagOn > 0 );
}
