/*
 * Copyright (c) 2014-2016, Freescale Semiconductor, Inc.
 * Copyright 2016 NXP
 * All rights reserved.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

/*
 * Generated by erpcgen 1.13.0 on Thu Apr 18 09:37:38 2024.
 *
 * AUTOGENERATED - DO NOT EDIT
 */


#if ERPC_ALLOCATION_POLICY == ERPC_ALLOCATION_POLICY_DYNAMIC
#include "erpc_port.h"
#endif
#include "erpc_codec.hpp"
#include "erpc_remote_control_app_0_client.hpp"
#include "erpc_manually_constructed.hpp"

#if 11300 != ERPC_VERSION_NUMBER
#error "The generated shim code version is different to the rest of eRPC code."
#endif

using namespace erpc;
using namespace std;
using namespace erpcShim;

//! @brief Function to read struct BoardConfig
static void read_BoardConfig_struct(erpc::Codec * codec, BoardConfig * data);

//! @brief Function to read struct AdcConfig
static void read_AdcConfig_struct(erpc::Codec * codec, AdcConfig * data);

//! @brief Function to read struct Vector
static void read_Vector_struct(erpc::Codec * codec, Vector * data);


// Read struct BoardConfig function implementation
static void read_BoardConfig_struct(erpc::Codec * codec, BoardConfig * data)
{
    if(NULL == data)
    {
        return;
    }

    codec->read(data->DAC);

    codec->read(data->MAG);

    for (uint32_t arrayCount0 = 0U; arrayCount0 < 3U; ++arrayCount0)
    {
        codec->read(data->RGB[arrayCount0]);
    }
}

// Read struct AdcConfig function implementation
static void read_AdcConfig_struct(erpc::Codec * codec, AdcConfig * data)
{
    if(NULL == data)
    {
        return;
    }

    codec->read(data->vref);

    codec->read(data->atomicSteps);
}

// Read struct Vector function implementation
static void read_Vector_struct(erpc::Codec * codec, Vector * data)
{
    if(NULL == data)
    {
        return;
    }

    codec->read(data->A_x);

    codec->read(data->A_y);

    codec->read(data->A_z);

    codec->read(data->M_x);

    codec->read(data->M_y);

    codec->read(data->M_z);
}




remote_control_app_0_client::remote_control_app_0_client(ClientManager *manager)
:m_clientManager(manager)
{
}

remote_control_app_0_client::~remote_control_app_0_client()
{
}

// remote_control_app_0 interface get_board_config function client shim.
void remote_control_app_0_client::get_board_config(BoardConfig * config)
{
    erpc_status_t err = kErpcStatus_Success;


#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = m_clientManager->getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = m_clientManager->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(message_type_t::kInvocationMessage, m_serviceId, m_get_board_configId, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        m_clientManager->performRequest(request);

        read_BoardConfig_struct(codec, config);

        err = codec->getStatus();
    }

    // Dispose of the request.
    m_clientManager->releaseRequest(request);

    // Invoke error handler callback function
    m_clientManager->callErrorHandler(err, m_get_board_configId);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = m_clientManager->getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    return;
}

// remote_control_app_0 interface get_adc_config function client shim.
void remote_control_app_0_client::get_adc_config(AdcConfig * config)
{
    erpc_status_t err = kErpcStatus_Success;


#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = m_clientManager->getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = m_clientManager->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(message_type_t::kInvocationMessage, m_serviceId, m_get_adc_configId, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        m_clientManager->performRequest(request);

        read_AdcConfig_struct(codec, config);

        err = codec->getStatus();
    }

    // Dispose of the request.
    m_clientManager->releaseRequest(request);

    // Invoke error handler callback function
    m_clientManager->callErrorHandler(err, m_get_adc_configId);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = m_clientManager->getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    return;
}

// remote_control_app_0 interface convert_dac_adc function client shim.
void remote_control_app_0_client::convert_dac_adc(uint32_t numberToConvert, uint32_t * result)
{
    erpc_status_t err = kErpcStatus_Success;


#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = m_clientManager->getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = m_clientManager->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(message_type_t::kInvocationMessage, m_serviceId, m_convert_dac_adcId, request.getSequence());

        codec->write(numberToConvert);

        // Send message to server
        // Codec status is checked inside this function.
        m_clientManager->performRequest(request);

        codec->read(*result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    m_clientManager->releaseRequest(request);

    // Invoke error handler callback function
    m_clientManager->callErrorHandler(err, m_convert_dac_adcId);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = m_clientManager->getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    return;
}

// remote_control_app_0 interface read_mag_accel function client shim.
void remote_control_app_0_client::read_mag_accel(Vector * results, bool * status)
{
    erpc_status_t err = kErpcStatus_Success;


#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = m_clientManager->getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = m_clientManager->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(message_type_t::kInvocationMessage, m_serviceId, m_read_mag_accelId, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        m_clientManager->performRequest(request);

        read_Vector_struct(codec, results);

        codec->read(*status);

        err = codec->getStatus();
    }

    // Dispose of the request.
    m_clientManager->releaseRequest(request);

    // Invoke error handler callback function
    m_clientManager->callErrorHandler(err, m_read_mag_accelId);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = m_clientManager->getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    return;
}

// remote_control_app_0 interface set_led function client shim.
void remote_control_app_0_client::set_led(uint8_t whichLed)
{
    erpc_status_t err = kErpcStatus_Success;


#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = m_clientManager->getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = m_clientManager->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(message_type_t::kOnewayMessage, m_serviceId, m_set_ledId, request.getSequence());

        codec->write(whichLed);

        // Send message to server
        // Codec status is checked inside this function.
        m_clientManager->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    m_clientManager->releaseRequest(request);

    // Invoke error handler callback function
    m_clientManager->callErrorHandler(err, m_set_ledId);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = m_clientManager->getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    return;
}
