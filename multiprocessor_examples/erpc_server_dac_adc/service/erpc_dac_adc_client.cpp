/*
 * Copyright (c) 2014-2016, Freescale Semiconductor, Inc.
 * Copyright 2016 NXP
 * All rights reserved.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

/*
 * Generated by erpcgen 1.13.0 on Thu Apr 18 09:37:38 2024.
 *
 * AUTOGENERATED - DO NOT EDIT
 */


#if ERPC_ALLOCATION_POLICY == ERPC_ALLOCATION_POLICY_DYNAMIC
#include "erpc_port.h"
#endif
#include "erpc_codec.hpp"
#include "erpc_dac_adc_client.hpp"
#include "erpc_manually_constructed.hpp"

#if 11300 != ERPC_VERSION_NUMBER
#error "The generated shim code version is different to the rest of eRPC code."
#endif

using namespace erpc;
using namespace std;
using namespace erpcShim;


// Constant variable definitions
#if defined(__MINGW32__)
__declspec( selectany )
#else
#pragma weak StringMaxSize
#endif
extern const uint8_t StringMaxSize = 11;

//! @brief Function to read struct AdcConfig
static void read_AdcConfig_struct(erpc::Codec * codec, AdcConfig * data);

//! @brief Function to read struct Vector
static void read_Vector_struct(erpc::Codec * codec, Vector * data);


// Read struct AdcConfig function implementation
static void read_AdcConfig_struct(erpc::Codec * codec, AdcConfig * data)
{
    if(NULL == data)
    {
        return;
    }

    codec->read(data->vref);

    codec->read(data->atomicSteps);
}

// Read struct Vector function implementation
static void read_Vector_struct(erpc::Codec * codec, Vector * data)
{
    if(NULL == data)
    {
        return;
    }

    codec->read(data->A_x);

    codec->read(data->A_y);

    codec->read(data->A_z);

    codec->read(data->M_x);

    codec->read(data->M_y);

    codec->read(data->M_z);
}




dac_adc_client::dac_adc_client(ClientManager *manager)
:m_clientManager(manager)
{
}

dac_adc_client::~dac_adc_client()
{
}

// dac_adc interface adc_get_config function client shim.
void dac_adc_client::adc_get_config(AdcConfig * config)
{
    erpc_status_t err = kErpcStatus_Success;


#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = m_clientManager->getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = m_clientManager->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(message_type_t::kInvocationMessage, m_serviceId, m_adc_get_configId, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        m_clientManager->performRequest(request);

        read_AdcConfig_struct(codec, config);

        err = codec->getStatus();
    }

    // Dispose of the request.
    m_clientManager->releaseRequest(request);

    // Invoke error handler callback function
    m_clientManager->callErrorHandler(err, m_adc_get_configId);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = m_clientManager->getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    return;
}

// dac_adc interface convert_dac_adc function client shim.
void dac_adc_client::convert_dac_adc(uint32_t numberToConvert, uint32_t * result)
{
    erpc_status_t err = kErpcStatus_Success;


#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = m_clientManager->getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = m_clientManager->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(message_type_t::kInvocationMessage, m_serviceId, m_convert_dac_adcId, request.getSequence());

        codec->write(numberToConvert);

        // Send message to server
        // Codec status is checked inside this function.
        m_clientManager->performRequest(request);

        codec->read(*result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    m_clientManager->releaseRequest(request);

    // Invoke error handler callback function
    m_clientManager->callErrorHandler(err, m_convert_dac_adcId);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = m_clientManager->getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    return;
}

// dac_adc interface set_led function client shim.
void dac_adc_client::set_led(uint8_t whichLed)
{
    erpc_status_t err = kErpcStatus_Success;


#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = m_clientManager->getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = m_clientManager->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(message_type_t::kInvocationMessage, m_serviceId, m_set_ledId, request.getSequence());

        codec->write(whichLed);

        // Send message to server
        // Codec status is checked inside this function.
        m_clientManager->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    m_clientManager->releaseRequest(request);

    // Invoke error handler callback function
    m_clientManager->callErrorHandler(err, m_set_ledId);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = m_clientManager->getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    return;
}

// dac_adc interface read_senzor_mag_accel function client shim.
void dac_adc_client::read_senzor_mag_accel(Vector * results)
{
    erpc_status_t err = kErpcStatus_Success;


#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = m_clientManager->getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = m_clientManager->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(message_type_t::kInvocationMessage, m_serviceId, m_read_senzor_mag_accelId, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        m_clientManager->performRequest(request);

        read_Vector_struct(codec, results);

        err = codec->getStatus();
    }

    // Dispose of the request.
    m_clientManager->releaseRequest(request);

    // Invoke error handler callback function
    m_clientManager->callErrorHandler(err, m_read_senzor_mag_accelId);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = m_clientManager->getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    return;
}

// dac_adc interface board_get_name function client shim.
void dac_adc_client::board_get_name(char * name)
{
    erpc_status_t err = kErpcStatus_Success;


#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = m_clientManager->getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = m_clientManager->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(message_type_t::kInvocationMessage, m_serviceId, m_board_get_nameId, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        m_clientManager->performRequest(request);

        {
            uint32_t name_len;
            char * name_local;
            codec->readString(name_len, &name_local);
            if ((StringMaxSize >= 0) && (name_len <= static_cast<uint32_t>(StringMaxSize)))
            {
                memcpy(name, name_local, name_len);
                (name)[name_len] = 0;
            }
            else
            {
                codec->updateStatus(kErpcStatus_InvalidArgument);
            }
        }

        err = codec->getStatus();
    }

    // Dispose of the request.
    m_clientManager->releaseRequest(request);

    // Invoke error handler callback function
    m_clientManager->callErrorHandler(err, m_board_get_nameId);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = m_clientManager->getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    return;
}
